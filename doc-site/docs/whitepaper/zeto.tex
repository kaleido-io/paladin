\section{Zeto}

The Zeto privacy domain consists of a collection of privacy-preserving, UTXO-based token implementations built using zero-knowledge proofs. Each Zeto token achieves a targeted subset of security properties. If the provided token implementations satisfy the security requirements for a given use case, then they can be deployed as-is. Otherwise, they can be used as templates for implementations that achieve new combinations of security goals.

This section starts by outlining the security properties targeted by Zeto tokens. We then describe how Zeto tokens achieve these properties while ensuring correctness with zero-knowledge proofs, and we illustrate how these tokens are implemented with an example.


\subsection{Preliminaries}

\subsubsection{UTXO Model}

All Zeto tokens are based on the ``unspent transaction output'' (UTXO) model~\cite{TODO}. In this model, all value is stored as records representing a certain amount of tokens that is available for a certain party to spend. We can conceptualize this as records $(\pk, v)$, where $\pk$ is the token owner's public key and $v$ is the amount of tokens they have available. A wallet will track all UTXO records corresponding to the owner's public key, and enable the owner to send tokens to other users.

UTXO-based transactions are constructed functionally: each transaction has a set of input UTXOs and output UTXOs, and the sender proves ownership of the inputs by signing the transaction with their private key. The output UTXO records can be assigned to any valid public key, including that of the sender themself.

This model achieves greater scalability and throughput than tokens using an account model~\cite{TODO}, where race conditions of simultaneous transactions touching the same account must be serialized. The UTXO model avoids this problem because all unique UTXOs stay in the memory of chain nodes, and double-spending can be prevented by simply checking for uniqueness of input UTXOs within each block. However, if $(\pk, v)$ pairs are stored in plaintext on-chain, this comes at the cost of privacy, because all tokens can be linked to their owners' public keys. Additionally, the movement of tokens through transactions reveals which parties are transacting, and how much value they exchange.


\subsubsection{Zero-Knowledge Proofs}

Zero-knowledge proofs~\cite{TODO} (ZK proofs or ZKP) allow a prover to convince a verifier that a given statement is true, without the verifier learning anything except that the statement is true. For example, a prover can convince a verifier that a given transaction is valid, i.e. the sum of the input values matches the sum of the output values, without revealing any of the transaction values themselves. The prover does this by performing a computation that would be impossible (with overwhelming probability) without knowledge of secret inputs. This type of argument is referred to as a succinct non-interactive argument of knowledge (SNARK)~\cite{TODO}. SNARKs serve as the engine underlying Zeto, enabling transaction privacy while enforcing transaction correctness in zero-knowledge. A user sending assets can generate proofs that assets are valid, and the proofs are verified on-chain by the Zeto token contract.

\paragraph{Implementation.} We implement our ZK proofs using \texttt{snarkjs}~\cite{TODO} and \texttt{circom}~\cite{TODO}. The \texttt{circom} library provides a high-level, developer-friendly syntax for specifying ZK proofs as circuits. Each proof demonstrates that a computation is performed honestly, and is represented as an arithmetic circuit over a prime-order field, with public inputs and outputs as well as private inputs. The generated proof then confirms knowledge of the secret input values such that the circuit computation is valid, without revealing any secret inputs. The \texttt{snarkjs} library provides the backend proof infrastructure that transforms a \texttt{circom} circuit and a set of inputs and outputs into a ZK proof. Several ZKP protocols are available: Groth16~\cite{TODO}, PLONK~\cite{TODO}, and FFLONK~\cite{TODO}. In Zeto we use Groth16. This system has the smallest proof size and fastest verifier algorithm (and therefore the lowest gas costs), at the expense of slower proof generation times. Groth16 also requires a once-per-circuit trusted setup ceremony. But these backends are easily swappable, so the provided token templates can be modified to use other backends for any given use case.


\subsection{Security Goals}

In this section, we describe the various security properties targeted by Zeto tokens. Each can be achieved independently, by adding a component to the ZK proof for a given token. We therefore also describe how each property is achieved within Zeto.

\paragraph{Anonymity.} This property ensures that no transaction reveals which user maintains ownership of a particular UTXO. Ownership of a particular UTXO is tied not to the \texttt{msg.signer} of a particular transaction, but to a private key stored off-chain. In this way, users can generate fresh signing keys for each EVM transaction without ever revealing the public key tied to a UTXO.

To achieve anonymity, we only store \textit{commitments} to UTXOs on chain, rather than the contents of the UTXO themselves. Each commitment is instantiated as a salted hash of $(\pk, v)$ pairs. In each token transfer, senders provide commitments to input UTXOs, and generate a SNARK to prove knowledge of the following values:
\begin{itemize}
  \item $(\pk, v_i)$ and salt values $\rho_i$ that constitute valid pre-images of each input commitment $i$.
  \item A secret key $\sk$ such that $(\pk, \sk)$ is a valid key pair.
  \item $(\pk_j, v_j)$ and salt values $\rho_j$ that constitute valid pre-images of each output commitment $j$.
\end{itemize}

The contract maintains a list of all valid UTXO commitments, and marks them as spent as they are consumed to prevent double-spending. When the Zeto contract verifies this proof, it is convinced that the input and output commitments it sees commit to a set of UTXOs that form a valid transaction. The sender can then reveal output UTXO information to the receivers out-of-band so they can use the committed-to UTXOs in future transactions. Note that anonymity (as described here) \textit{does not} hide relationships between input and output UTXOs. All UTXOs have a fixed salt and a fixed commitment stored on-chain. Unlinkability between any UTXOs in a given transaction is achieved by using nullifiers, as described below.

% instead of revealing input values for each input and output UTXO, we just reveal the UTXOs themselves
% UTXO == commitment (these are used interchangably in the code)
% this is like "input and output hiding"

\paragraph{Encryption of secrets} % TODO: find a better name for this

% uses poseidon encryption
% encrypts the output UTXO information: the tx value and salt for the UTXO
% No additional privacy over "anonymity". the difference is that here we store encryptions of the output UTXO values and salts on the base chain.
% don't rely on off-chain channels for receivers to get necessary secrets
% malicious sender can't hide the sent tokens from the receiver

\paragraph{History masking.}

% nullifiers hide which input UTXOs are used
% this achieves "unlinkability" of input values to outputs, while guaranteeing that valid inputs do exist

\paragraph{Know Your Customer (KYC).}

% verifies that the input user is a member of a sparse merkle tree (SMT) that holds known users

\paragraph{Non-repudiation}

% encrypts tx info (input and output owner, input and output values and salts) to be decrypted by an authority
% identical to qurrency but not post-quantum secure < ** maybe note qurrency here **

In addition to the above security properties, all contracts enforce transaction correctness with ZK proofs. Specifically, the proofs ensure the following.
\begin{itemize}
  \item The sum of input UTXO values is equal to the sum of the output values.
  \item All output UTXO values are positive.
  \item The sender owns private keys corresponding to public keys for all input UTXOs.
\end{itemize}




\subsection{Example Token: \texttt{anon\_nullifier\_kyc}} % we can maybe change which token this section is focused on

% show diagram of the ZK circuit
% reiterate points from "preliminaries": ZK proof ensures honest transaction generation, but only a subset of the values are revealed publicly